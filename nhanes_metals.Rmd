---
title: "nhanes_metals"
author: "Nicole Comfort"
date: "12/17/2019"
output: html_document
---

First, check whether you have the necessary packages installed and if not, install them.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) 
 
##  install necessary packages

#install.packages("tidyverse")
#install.packages("NHANES") # example NHANES data to play with 
#install.packages("survey") # Used to take into account complex survey designs like NHANES
## Documentation for this package is: https://cran.r-project.org/web/packages/survey/survey.pdf
 
# install.packages("Hmisc")
# install.packages("foreign")
# install.packages("labelled")
# install.packages("knitr")
# install.packages("kableExtra")
# install.packages("ggsignif")
# install.packages("ggarrange")
# install.packages("ggpubr")

# load libraries
library(tidyverse) 
library(NHANES)
library(survey) # This package handles survey weights/designs easily
options(survey.lonely.psu = "adjust")
library(Hmisc) # This is a package (H misc.) for basic desciptive functions.
library(foreign) # This package allows us to open .XPT files
library(labelled)
library(knitr)
library(kableExtra)
library(moments)
library(ggsignif)
library(patchwork)
# library(ggarrange) Not available for R version 3.5.1
library(ggpubr)

# set figure themes 
theme_set(theme_bw())
theme_update(plot.title = element_text(hjust = 0.5)) # centers plot titles
theme_update(axis.text.y = element_text(size = 12)) # increase font size of y axis text

```

# Background:  
The National Health and Nutrition Examination Survey (NHANES) is a nationally-representative survey of the general, noninstutionalized US civilian population conducted by the National Center for Health Statistics. NHANES is a multi-stage sample completed in two-year cycles. Participants are chosen to represent the entire general U.S., but certain age groups and racial/ethnic groups are intentionally oversampled to ensure adequate power to analyze these populations.

Participants undergo thorough examination including demographic questionnaire, a 24-hr dietary recall, a clinical examination, and a laboratory examination. All NHANES protocols were approved by the National Center for Health Statistics institutional review board, and all participants gave written informed consent.

For more information on NHANES, view the Centers for Disease Control and Prevention (CDC) website: https://www.cdc.gov/nchs/nhanes/index.htm

### Note:
NHANES does not measure every environmental chemical in every participant. For some environmental chemicals, these measurements are only done on a subset of participant samples and there are special sub-weights that need to be used for analyzing these chemicals. 

Here, we will explore the *unadjusted* levels of lead, cadmium, mercury, and manganese measured in blood of males versus females to examine if there is a sex difference in body burden of these chemicals.

We will conduct this analysis in one two-year survey cycle (2015/2016), *since combining weights across survey cycles is very complex.* See http://www.cdc.gov/nchs/tutorials/NHANES/SurveyDesign/Weighting/intro.htm for more information. 

# Download NHANES Data and Clean

The data files must first be downloaded. They can be found and downloaded at the NHANES website: https://wwwn.cdc.gov/nchs/nhanes/continuousnhanes/default.aspx?BeginYear=2015 

```{r NHANES data}

# Load data

# Demographic files for 2015-2016
demo1516 <- read.xport("DEMO_I.XPT") %>% 
  arrange(SEQN)

## Data documentation file: https://wwwn.cdc.gov/Nchs/Nhanes/2015-2016/DEMO_I.htm

# Laboratory blood Pb, Cd, Hg, Mn files for 2015-2016
cd1516 <- read.xport("PBCD_I.XPT") %>% 
  arrange(SEQN)
## Data documentation file: https://wwwn.cdc.gov/Nchs/Nhanes/2015-2016/PBCD_I.htm
### Eligible Sample: All examined participants aged 1-11 years old, and a one-half sample from participants aged 12 years and older were eligible. 

# Inorganic, Ethyl, Methyl Mercury for 2015-2016
hg1516 <- read.xport("IHGEM_I.XPT") %>% 
  arrange(SEQN)
## Data documentation file: https://wwwn.cdc.gov/Nchs/Nhanes/2015-2016/IHGEM_I.htm
### Eligible Sample: All examined participants aged 1-11 years old, and a one-half sample from participants aged 12 years and older were eligible.

######################

# Total Mercury in Urine for 2015-2016
uhg1516 <- read.xport("UHG_I.XPT") %>% 
  arrange(SEQN)
## Data documentation file: https://wwwn.cdc.gov/Nchs/Nhanes/2015-2016/UHG_I.htm
### Eligible Sample: All examined participants aged 3 to 5 years were eligible and participants aged 6 years and older from a one-third subsample were eligible.
#### Note that this is different weighting scheme than for blood metals

## Arsenic
# Speciated urinary arsenics for 2015-2016
uas_sp <- read.xport("UAS_I.XPT") %>% 
  arrange(SEQN)
## Data documentation file: https://wwwn.cdc.gov/Nchs/Nhanes/2015-2016/UAS_I.htm
### Eligible Sample: All examined participants aged 3 to 5 years were eligible and participants aged 6 years and older from a one-third subsample were eligible.

# Total urinary arsenic for 2015-2016
uas_t <- read.xport("UTAS_I.XPT") %>% 
  arrange(SEQN)
## Data documentation file: https://wwwn.cdc.gov/Nchs/Nhanes/2015-2016/UTAS_I.htm
### Eligible Sample: All examined participants aged 3 to 5 years were eligible and participants aged 6 years and older from a one-third subsample were eligible.

# creatinine for 2015-2016 (for adjustment of urinary arsenic and urinary mercury)
creatinine <- read.xport("ALB_CR_I.XPT") %>% 
  arrange(SEQN)
## Data documentation file: https://wwwn.cdc.gov/Nchs/Nhanes/2015-2016/ALB_CR_I.htm
### Eligible Sample: Examined participants aged 3 years and older were eligible.

``` 

## Blood Metals: Subset Data Cleaning and Evaluation

```{r create blood metal dataframe}

# Blood metal dataframe 

# Merge data to create one dataframe per year; then keep only the necessary variables:
nh1516 <- merge(demo1516, cd1516, by = "SEQN", all = TRUE)
nh1516 <- merge(nh1516, hg1516, by = c("SEQN", "WTSH2YR"), all = TRUE)
# later, exclude those who have WTSH2YR as "NA"

# double check that there aren't repeat columns renamed [col_name].x or [col_name].y

## Here is a list of variables we will need for our analysis:
# SEQN, SDDSRVYR, RIAGENDR, RIDAGEYR, RIDRETH1, WTMEC2YR, SDMVPSU, SDMVSTRA, WTSH2YR
# LBXBPB (blood lead), LBXBCD (blood cadmium),
# LBXBSE (blood selenium), LBXBMN (blood manganese)
# LBXTHG (blood total mercury), LBXIHG (blood inorganic mercury),
# LBXBGE (ethyl mercury), LBXBGM (methyl mercury)

# Retain only necessary variables:
nh1516_sub <-
  nh1516 %>%
  select(SEQN, SDDSRVYR, # unique identifier and survey year 
         RIAGENDR, RIDAGEYR, RIDRETH1, # gender, age, race/ethnicity
         WTMEC2YR, SDMVPSU, SDMVSTRA, WTSH2YR, # weighting info
         LBDBPBLC, LBDBCDLC, LBDTHGLC, LBDBMNLC,  # comment codes for blood metals LOD 
         LBDIHGLC, LBDBGELC, LBDBGMLC, # blood Hg comment codes for LOD
         LBXBPB, LBXBCD, LBXBMN, LBXTHG, LBXIHG, LBXBGE, LBXBGM) %>% # metals (exclude selenium for now)
  janitor::clean_names() %>% 
  mutate(lbxohg = lbxthg - lbxihg) %>% # create new variable for organic mercury (total Hg - inorganic Hg)
  rename(sex = riagendr,
         age = ridageyr,
         race = ridreth1) %>% 
  set_value_labels(                     # Label variable values
    sex = c("Male" = 1, "Female" = 2), 
    race = c("Mexican American" = 1,
             "Other Hispanic" = 2,
             "NH White" = 3,
             "NH Black" = 4,
             "Other including multi" = 5)) %>% 
  mutate_if(is.labelled, to_factor)  # Treat any labelled variables (e.g. sex) as factors


# Note to self: why are some organic mercury values (the variable I created) negative?? 
# PROBABLY BECAUSE THERE ARE A LOT OF IMPUTED VALUES SO THEY DON'T ADD UP 

# later, plot mercury broken down as organic and inorganic, but also try breaking down organic to ethyl and methyl
# or Annie's recommendation was just to plot total and methyl?  

```

Blood metals are measured in all participants aged 1-11 years old, and additionally in only a one-half subsample of participants 12 years and older.

Let's find how many people are missing the weight value, indicating that they did not have their blood metals measured: 

```{r remove NAs and 0 weights}

# assess missingness of weights variable to see how many were eligible
# those that were eligible, i.e. all participants 1-11 and half of participants aged 12 and older will have a wtsh2yr value that is not equal to 0 
nh1516_sub %>% 
  count(is.na(wtsh2yr))

# The appropriate sample weights are provided in the variable WTSH2YR in this data file for all participants and should be used when analyzing these data.

# The analytes included in this dataset were measured for all examined participants aged 1-11 years, and in a one-half subsample of participants 12 years and older. For participants aged 1-11 years their WTSH2YR are equivalent to their MEC exam sample weights. These 1-11 years old participants have completed at least one physical exam component in the MEC; therefore, they all have an exam sample weight larger than “0,” regardless of their lab test results.

# For participants 12 years and older, special sample weights were created for the subsample. These special weights accounted for the additional probability of selection into the subsample, as well as the additional nonresponse to these lab tests. Therefore, if a participant 12 years and older was selected as part of the one-half subsample, but did not provide a blood specimen, he/she would have the sample weight value assigned as “0” in his/her record. 

# so would including someone with weight 0 make a difference?? Can I just exclude them?? 

# drop rows missing the weight variable to arrive at the eligible subset
nh1516_sub <- 
  nh1516_sub %>%  
  drop_na(wtsh2yr) %>%   
  filter(wtsh2yr != 0)  
   
```

Of the 9,971 participants surveyed in 2015-2016, `r {nrow(nh1516_sub)}` were eligible to have blood metals measured.

Check the percentage of imputed values for blood Pb, Cd, Mn, and total Hg:

```{r blood metals below LOD}

# The variable name ending in “LC” (ex., LBDBCDLC) indicates whether the result was below the limit of detection: the value “0” means that the result was at or above the limit of detection, “1” indicates that the result was below the limit of detection.

# For analytes with analytic results below the lower limit of detection (ex. LBDBCDLC=1), an imputed fill value was placed in the analyte results field. This value is the lower limit of detection divided by the square root of 2 (LLOD/sqrt[2]). 

nh1516_sub %>% 
  count(lbdbpblc == 1) # only 5 imputed values for Pb, < 1% imputed 

nh1516_sub %>% 
  count(lbdbcdlc == 1) # ouch, 23% < LOD for Cd, that's 34% if I include the 609 that have comment code "NA" 

nh1516_sub %>% 
  count(lbdthglc == 1) # same as for Cd, ~23% < LOD for total Hg

nh1516_sub %>% 
  count(lbdbmnlc == 1) # 610 NA but otherwise no imputed values for Mn  
 
```

The LODs for Pb, Cd, total Hg, and Mn are 0.07 ug/dL, 0.1 ug/L, 0.28 ug/L, and 0.99 ug/L, respectively.

Virtually all participants had values > LOD for Pb and Mn, but 22% of participants had values < LOD for Cd and total Hg.

### Blood Metals: Missing Data

Let's further evaluate missing data. Of those eligible, how many did not have blood metals measured? 

```{r evaluate missing metal data}

# of those eligible, how many are missing values of our metals of interest (Pb, Cd, Hg, Mn)? 

## NOTE: According to the NHANES website, as a general rule, if 10% or less of your data for a variable are missing from your analytic dataset, it is usually acceptable to continue your analysis without further evaluation or adjustment
### However, if > 10% of the data for a variable are missing, you may need to determine whether the missing values are distributed equally across socio-demographic characteristics, and decide whether further imputation of missing values or use of adjusted weights are necessary 

# for Pb
nh1516_sub %>%
  count(is.na(lbxbpb))
# 609, or 10.88% still missing data.... seems extremely high, should probably check to see whether missingness is at random or not 

# for Cd
nh1516_sub %>%
  count(is.na(lbxbcd))
# 10.88% missing data
 
# for total Hg 
nh1516_sub %>%
  count(is.na(lbxthg)) 
# 10.88% missing data  

# for methyl Hg
nh1516_sub %>% 
  count(is.na(lbxbgm))

# for Mn 
nh1516_sub %>%
  count(is.na(lbxbmn))
# 10.89% missing data  

# drop rows with missing values
nh1516_sub <- 
  nh1516_sub %>% 
  drop_na(lbxbpb, lbxbmn)
 
```

From our eligible subset, about 11% had missing values for blood metals Pb, Cd, Mn, and total Hg. Thus, after removing participants with missing values, we are left with `r {nrow(nh1516_sub)}` for analysis.

## Inorganic, Ethyl, and Methyl Mercury: Subset Data Cleaning and Evaluation

### Inorganic, Ethyl, and Methyl Mercury: Missing Data

```{r create separate dataset for speciated mercury, include=FALSE}
# assess missingness 

# for ethyl Hg
nh1516_sub %>% 
  count(is.na(lbxbge)) 
# 52 participants missing values.

# for methyl Hg
nh1516_sub %>%
  count(is.na(lbxbgm))
# 50 participants missing values.

# for inorganic Hg
nh1516_sub %>%
  count(is.na(lbxihg))
# 50 participants missing values.
 
# create separate data subset for speciated mercury including only the complete cases
hg1516_sub <-   
  nh1516_sub %>% 
 # drop_na(lbxbge) %>%   # remove missing ethyl mercury 
  drop_na(lbxbgm) %>%    # remove missing methyl mercury 
  select(-lbxbpb, -lbxbcd, -lbxbmn)
 
```

Because there were additional participants missing values of mercury (inorganic, ethyl, and methyl), we created a separate dataset, `hg1516`, for speciated blood mercury. After retaining only complete cases, we are left with `r {nrow(hg1516_sub)}` participants for mercury analysis. 

```{r speciated mercury < LOD, include = FALSE}

# The variable name ending in “LC” (ex., LBDBCDLC) indicates whether the result was below the limit of detection: the value “0” means that the result was at or above the limit of detection, “1” indicates that the result was below the limit of detection.

# For analytes with analytic results below the lower limit of detection (ex. LBDBCDLC=1), an imputed fill value was placed in the analyte results field. This value is the lower limit of detection divided by the square root of 2 (LLOD/sqrt[2]). 

hg1516_sub %>% 
  count(lbdihglc == 1) # for iHg, 85% of values are imputed 

hg1516_sub %>% 
  count(lbdbgelc == 1) # for ethyl Hg, ~99% values imputed

hg1516_sub %>% 
  count(lbdbgmlc == 1) # for methyl Hg, 27% of values imputed (OK)
 
hg1516_sub %>% 
  count(lbdthglc == 1) # for total Hg, 25% of values imputed (OK)
 
```

The LOD for inorganic, ethyl, and methyl mercury are 0.27 ug/L, 0.16 ug/L, and 0.12 ug/L, respectively. 
Too many participants had imputed values for inorganic Hg (85%) and ethyl Hg (99%) so that these variables are not informative. Thus, we will only examine total Hg and meHg measured in blood.

## Urinary Mercury: Subset Data Cleaning and Evaluation

The concentration of total Hg in urine is a biomarker of exposure primarily to elemental and inorganic Hg, although some Hg in urine comes from de-methylation of methyl Hg in blood (Abe et al., 1995). Thus, examining total Hg in urine better reflects exposure to inorganic Hg.

NHANES 2015/2016 collected information on Hg in urine. We will analyze this data from NHANES 2015/2016 as well.

```{r create urinary mercury dataframe, include=FALSE}

# urinary Hg dataframe  
 
# Merge data to create one dataframe per year; then keep only the necessary variables: 
uhg1516 <- merge(demo1516, uhg1516, by = "SEQN", all = TRUE)  
uhg1516 <- merge(uhg1516, creatinine, by = "SEQN", all = TRUE) 
# later, exclude those who have WTSA2YR as "NA"
 
## Here is a list of variables we will need for our analysis:
# SEQN, SDDSRVYR, RIAGENDR, RIDAGEYR, RIDRETH1, WTMEC2YR, SDMVPSU, SDMVSTRA
# WTSA2YR (NEW WEIGHTING VARIABLE)
# URXUHG (urine mercury, ng/mL), URXUCR (creatinine, mg/dL)
 
# Data Cleaning to Create Urinary Hg Data Subset: 
uhg1516_sub <-
  uhg1516 %>%
  select(SEQN, SDDSRVYR, # unique identifier and survey year 
         RIAGENDR, RIDAGEYR, RIDRETH1, # gender, age, race/ethnicity
         URDUHGLC, # urine comment code 
         WTMEC2YR, SDMVPSU, SDMVSTRA, WTSA2YR, # weighting info
         URXUHG, URXUCR) %>% # metals (exclude selenium for now)
  janitor::clean_names() %>% 
  mutate(cr_ng_ml = urxucr*10000) %>% # convert creatining from mg/dL to ng/mL
  mutate(urxuhg_adj = urxuhg/cr_ng_ml) %>% # urine hg adjusted for creatinine 
  rename(sex = riagendr,
         age = ridageyr,
         race = ridreth1) %>% 
  set_value_labels(                     # Label variable values
    sex = c("Male" = 1, "Female" = 2), 
    race = c("Mexican American" = 1,
             "Other Hispanic" = 2,
             "NH White" = 3,
             "NH Black" = 4,
             "Other including multi" = 5)) %>% 
  mutate_if(is.labelled, to_factor)  # Treat any labelled variables (e.g. sex) as factors
 
```

Urinary mercury is eligible to be measured in all participants aged 3 to 5 years and in a one-third subsample of participants aged 6 years and older.

### Urinary Mercury: Missing Data

Let's find how many people are missing the weighting value, indicating that they did not have their urinary mercury measured: 

```{r remove NAs and 0 weights for urinary Hg, include=FALSE}
 
# assess missingness of weights variable to see how many were eligible 
# those that were eligible, i.e. all participants 3-5 and one-third of participants aged 6 and older will have a wtsa2yr value that is not equal to 0  
uhg1516_sub %>%  
  count(is.na(wtsa2yr))
# there are more missing than for blood metals, which makes sense because we sampled only one third of the eligible participants rather than one-half and also are missing data for children < 3 years old
 
# drop rows missing the weight variable to arrive at the eligible subset
uhg1516_sub <-
  uhg1516_sub %>% 
  drop_na(wtsa2yr) %>%  
  filter(wtsa2yr != 0)  
 
```

Of the 9,971 participants surveyed in 2015-2016, `r {nrow(uhg1516_sub)}` were eligible to have urine mercury measured.

```{r drop missing mercury and creatinine, include=FALSE}

# assess missing 
uhg1516_sub %>%
  count(is.na(urxuhg)) 

uhg1516_sub %>%
  count(is.na(urxucr))

uhg1516_sub %>%
  count(is.na(urxuhg_adj))

# drop rows with missing Hg and creatinine values
uhg1516_sub <-
  uhg1516_sub %>% 
  drop_na(urxuhg, urxucr)

```

Furthermore, out of those eligible, about 4.6% were missing values for urinary mercury. After dropping those with values missing for urinary mercury and/or creatinine (needed for adjustment), we have `r {nrow(uhg1516_sub)}` participants remaining for analysis. 

```{r urinary Hg assess LODs, include = FALSE}

# The variable name ending in “LC” (ex., LBDBCDLC) indicates whether the result was below the limit of detection: the value “0” means that the result was at or above the limit of detection, “1” indicates that the result was below the limit of detection. 
 
# For analytes with analytic results below the lower limit of detection (ex. LBDBCDLC=1), an imputed fill value was placed in the analyte results field. This value is the lower limit of detection divided by the square root of 2 (LLOD/sqrt[2]).  

uhg1516_sub %>%  
  count(urduhglc == 1) # for urinary Hg, 58% of values are < LOD 
  
```

The LOD for urinary Hg is 0.13 ug/L. 58% of participants had values that were below the LOD. **Thus, urinary Hg in this dataset is not informative and we will not be analyzing it.** 

## Urinary Arsenic: Subset Data Cleaning and Evaluation

```{r create urinary arsenic dataframe, include = FALSE}

# Urinary arsenic dataframe 

# Merge data to create one dataframe per year; then keep only the necessary variables:
uas1516 <- merge(demo1516, creatinine, by = "SEQN", all = TRUE)
uas1516 <- merge(uas1516, uas_sp, by = "SEQN", all = TRUE) 
uas1516 <- merge(uas1516, uas_t, by = "SEQN", all = TRUE)
 
uas1516 <- uas1516 %>% 
  mutate(WTSA2YR = WTSA2YR.x) 
 
# later, exclude those who have WTSA2YR as "NA"

# Note that the total arsenic file, uas_t, did not have a comment code. 
# The LOD for total urinary arsenic is 0.26 ug/L, so let's just count how many participants have values < 0.26

uas1516 %>% 
  count(URXUAS < 0.26) # only two people have imputed values, so no need to worry! 

## Here is a list of variables we will need for our analysis:
# SEQN, SDDSRVYR, RIAGENDR, RIDAGEYR, RIDRETH1, WTMEC2YR, SDMVPSU, SDMVSTRA
# WTSA2YR (NEW WEIGHTING VARIABLE)
# URXUCR (creatinine, mg/dL) 
# URXUAS3, URXUAS5, URXUAB, URXUAC, URXUDMA, URXUMMA (all in ug/L)
# URXUAS (total urine arsenic, ug/L)
 
# Data Cleaning to Create Urinary Hg Data Subset: 
uas1516_sub <-
  uas1516 %>%
  select(SEQN, SDDSRVYR, 
         RIAGENDR, RIDAGEYR, RIDRETH1, 
         WTMEC2YR, SDMVPSU, SDMVSTRA, WTSA2YR, 
         URDUA3LC, URDUA5LC, URDUABLC, URDUACLC, URDUDALC, URDUMMAL, # comment codes
         URXUCR, URXUAS3, URXUAS5, URXUAB, URXUAC, URXUDMA, URXUMMA, URXUAS) %>%
  janitor::clean_names() %>% 
  mutate(urxucr = urxucr*10000) %>% # convert creatinine from mg/dL to ug/L 
  #mutate(urxuas3 = urxuas3/urxucr, # did I adjust correctly?? 
         #urxuas5 = urxuas5/urxucr,
         #urxuab = urxuab/urxucr,
         #urxuac = urxuac/urxucr,
         #urxudma = urxudma/urxucr,
         #urxumma = urxumma/urxucr,
         #urxuas = urxuas/urxucr) %>% # urine arsenic adjusted for creatinine 
  rename(sex = riagendr,
         age = ridageyr,
         race = ridreth1) %>% 
  set_value_labels(                     # Label variable values
    sex = c("Male" = 1, "Female" = 2), 
    race = c("Mexican American" = 1,
             "Other Hispanic" = 2,
             "NH White" = 3,
             "NH Black" = 4,
             "Other including multi" = 5)) %>% 
  mutate_if(is.labelled, to_factor)  # Treat any labelled variables (e.g. sex) as factors
 

```

Urinary arsenic (total and speciated) is eligible to be measured in all participants aged 3 to 5 years and in a one-third subsample of participants aged 6 years and older.

### Urinary Arsenic: Missing Data

Let's find how many people are missing the weighting value, indicating that they did not have their urinary mercury measured: 

```{r remove NAs and 0 weights for urinary arsenic, include=FALSE}
 
# assess missingness of weights variable to see how many were eligible
# those that were eligible, i.e. all participants 3-5 and one-third of participants aged 6 and older will have a wtsa2yr value that is not equal to 0 
uas1516_sub %>% 
  count(is.na(wtsa2yr))

# drop rows missing the weight variable to arrive at the eligible subset
uas1516_sub <-
  uas1516_sub %>% 
  drop_na(wtsa2yr) %>%  
  filter(wtsa2yr != 0)  

```

Of the 9,971 participants surveyed in 2015-2016, `r {nrow(uas1516_sub)}` were eligible to have urine arsenic measured.

```{r drop missing urinary arsenic and DMA, include=FALSE}
 
# assess missing 
uas1516_sub %>%
  count(is.na(urxuas))

uas1516_sub %>% 
  count(is.na(urxudma))

uhg1516_sub %>%
  count(is.na(urxucr))

# drop rows with missing total arsenic and creatinine values
uas1516_sub <-
  uas1516_sub %>% 
  drop_na(urxuas, urxucr)

# Note, after this, there is just one person missing a DMA value, let's just exclude them as well 
uas1516_sub <-
  uas1516_sub %>% 
  drop_na(urxudma)

```

Furthermore, out of those eligible, 5.4% were missing values for total arsenic and DMA. After dropping those with values missing for urinary arsenic and/or creatinine (needed for adjustment), we have `r {nrow(uas1516_sub)}` participants remaining for analysis. 

```{r speciated arsenic < LOD, include = FALSE}

# The variable name ending in “LC” (ex., LBDBCDLC) indicates whether the result was below the limit of detection: the value “0” means that the result was at or above the limit of detection, “1” indicates that the result was below the limit of detection.

# For analytes with analytic results below the lower limit of detection (ex. LBDBCDLC=1), an imputed fill value was placed in the analyte results field. This value is the lower limit of detection divided by the square root of 2 (LLOD/sqrt[2]). 

uas1516_sub %>% 
  count(urdua3lc == 1) # 47% < LOD for arsenous acid

uas1516_sub %>% 
  count(urdua5lc == 1) # 97% < LOD for arsenic acid

uas1516_sub %>% 
  count(urduablc == 1) # 60% < LOD for arsenobetaine

uas1516_sub %>% 
  count(urduaclc == 1) # 83% < LOD for arsenocholine 

uas1516_sub %>%  
  count(urdudalc == 1) # 29% < LOD for dimethylarsinic acid (DMA) 
 
uas1516_sub %>% 
  count(urdummal == 1) # 44% < LOD for monomethylarsonic acid (MMA) 
  
```

The LOD for urinary total arsenic is 0.26 ug/L. Virtually all participants had a measurement of urinary total arsenic above the LOD. However, other than DMA, the percentage of participants with values < LOD were too high and so those species will not be analyzed. 29% of participants have values < LOD for DMA. This is a little on the high end, but we will still evaluate it.

### Total N's

There were `r {nrow(nh1516)}` participants surveyed in the NHANES 2015-2016 cycle.

In our data subsets, there are:

* `r {nrow(nh1516_sub)}` participants with Pb, Cd, Mn, and total Hg measured in blood,

* `r {nrow(hg1516_sub)}` participants with inorganic, ethyl, and methyl Hg measured in blood,

* `r {nrow(uhg1516_sub)}` participants Hg measured in urine,

* `r {nrow(uas1516_sub)}` participants with total and speciated arsenic measured in urine

for our analyses.

# Sample Weighting

Note that NHANES is designed to sample larger numbers of certain subgroups of particular public health interest (e.g. low income Americans, African Americans). Oversampling is done to increase the reliability and precision of estimates of health status indicators for these population subgroups. To account for this sampling design and these design features in our analysis, it is critical that we apply sample weights.

Continue data cleaning by applying appropriate sample weights, which will allow us to calculate unbiased estimates.

## Survey Weights

```{r survey weighting, echo=FALSE}
 
# Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
# Primary Sampling Units (PSU)  
 
# Here we use "svydesign" to assign the weights. We will use this new survey design variable when running our analyses
# Blood Pb, Cd, Mn
blood.svy <- svydesign(ids = ~sdmvpsu, # cluster IDs
                        strata = ~sdmvstra, # strata IDs
                        weights = ~wtsh2yr, # individual weights, subsample descriptions and weights are found in the specific datafiles downloaded from NHANES website
                        nest = TRUE,
                        data = nh1516_sub) # call the dataframe 

summary(blood.svy) 

# Blood Hg
########################################
blood.hg.svy <- svydesign(ids = ~sdmvpsu, 
                        strata = ~sdmvstra, 
                        weights = ~wtsh2yr, 
                        nest = TRUE,
                        data = hg1516_sub) # call the dataframe 

summary(blood.hg.svy) 

# Urinary Hg
########################################
urine.hg.svy <- svydesign(ids = ~sdmvpsu, 
                        strata = ~sdmvstra, 
                        weights = ~wtsa2yr, 
                        nest = TRUE,
                        data = uhg1516_sub)  

summary(urine.hg.svy) 

# urinary arsenic
########################################
arsenic.svy <- svydesign(ids = ~sdmvpsu,
                        strata = ~sdmvstra,  
                        weights = ~wtsa2yr, 
                        nest = TRUE, 
                        data = uas1516_sub) 

summary(arsenic.svy) 

# account for non-response (since there are many sub-components of NHANES, incl. interview, labs, exposure data)
# thus, sub-samples have different weights because not all participants are invited to participate in all sub-components

## If you want to combine weights across sub-samples within a survey cycle or across survey cycles, this is even more complex
## Advice: don’t do it unless you understand what you are doing.  

```

## Survey-Weighted Data Distributions

### Data Distribution: Blood Metals

After analyzing the data distributions for all variables we will consider, we decided we will log-transform each metal variable to create a more normal distribution. 

```{r blood metals check distributions, include=FALSE}

# check the distribution and normality of the data and identify outliers for continuous variables
# "svyhist" creates histograms accounting for survey weights

## Lead
svyhist(~lbxbpb,
        blood.svy,
        main = "Survey weighted average blood Pb", col = "blue")
# right-skewed

# Pb log transformed
svyhist(~log(lbxbpb),
        blood.svy,
        main =  "Survey weighted log(average blood Pb)", col = "blue")
# log transformed data now normal

## Cadmium
svyhist(~lbxbcd,
        blood.svy,
        main = "Survey weighted average blood Cd", col = "red")
# right-skewed

# Cd log transformed
svyhist(~log(lbxbcd),
        blood.svy,
        main = "Survey weighted log(average blood Cd)", col = "red")

svyhist(~log10(lbxbcd),
        blood.svy,
        main = "Survey weighted log10(Cd)")

## log-transformed Cd still not quite normal??? 

## Total Mercury
svyhist(~lbxthg,
        blood.svy,
        main = "Survey weighted average blood total Hg", col = "cyan")
# right-skewed

# tHg log transformed
svyhist(~log(lbxthg),
        blood.svy,
        main = "Survey weighted log(average blood total Hg)", col = "cyan")
## log-transformed tHg still not quite normal??? 
 
## Manganese 
svyhist(~lbxbmn,
        blood.svy, 
        main = "Survey weighted average blood Mn", col = "yellow")
# right-skewed

# Mn log transformed 
svyhist(~log(lbxbmn),
        blood.svy,
        main = "Survey weighted log(average blood Mn)", col = "yellow")
# log-transformed now normal

## Do I have to test these distributions for normality statistically?? 
```

```{r blood metals skewness, include=FALSE}
# but this doesn't take into account the weighting....? or is the weighting only needed for statistical tests but not for assessments of normality?  
  
# Pb skewness/kurtosis 
skewness(nh1516_sub$lbxbpb)
kurtosis(nh1516_sub$lbxbpb)
# log transformed Pb skewness/kurtosis
skewness(log(nh1516_sub$lbxbpb))
kurtosis(log(nh1516_sub$lbxbpb))

###

# Cd skewness/kurtosis
skewness(nh1516_sub$lbxbcd)
kurtosis(nh1516_sub$lbxbcd)
# log transformed Cd skewness/kurtosis
skewness(log(nh1516_sub$lbxbcd))
kurtosis(log(nh1516_sub$lbxbcd))

# log 10 transformed Cd 
skewness(log10(nh1516_sub$lbxbcd))
kurtosis(log10(nh1516_sub$lbxbcd))
# log 10 transformed qqplot
qqnorm(log10(nh1516_sub$lbxbcd))
qqline(log10(nh1516_sub$lbxbcd))
# doesn't change the qqplot except for scale
 
###

# Mn skewness/kurtosis
skewness(nh1516_sub$lbxbmn) 
kurtosis(nh1516_sub$lbxbmn) 
# log transformed Mn skewness/kurtosis
skewness(log(nh1516_sub$lbxbmn))
kurtosis(log(nh1516_sub$lbxbmn)) 

 
```

```{r blood metals QQ plots, include=FALSE}

# Pb qqplot  
qqnorm(nh1516_sub$lbxbpb) 
qqline(nh1516_sub$lbxbpb)

# log transformed qqplot, Pb
qqnorm(log(nh1516_sub$lbxbpb))
qqline(log(nh1516_sub$lbxbpb))

# Cd qqplot
qqnorm(nh1516_sub$lbxbcd) 
qqline(nh1516_sub$lbxbcd)

# log transformed qqplot, Cd
qqnorm(log(nh1516_sub$lbxbcd))
qqline(log(nh1516_sub$lbxbcd))

# Mn qqplot
qqnorm(nh1516_sub$lbxbmn) 
qqline(nh1516_sub$lbxbmn)

# log transformed qqplot, Mn
qqnorm(log(nh1516_sub$lbxbmn))
qqline(log(nh1516_sub$lbxbmn))

```

```{r blood metals check impact of influential outliers}

# plot the survey weight against the variable to determine which extreme values are outliers
nh1516_sub %>% 
  ggplot(aes(x = log(lbxbpb), y = wtsh2yr)) +
  geom_point()

#nh1516_sub %>% 
#  ggplot(aes(x = wtsh2yr, y = log(lbxbpb))) +
#  geom_point()

# what should this plot look like?? 

# Cd
nh1516_sub %>% 
  ggplot(aes(x = log(lbxbcd), y = wtsh2yr)) +
  geom_point()

# Mn
nh1516_sub %>% 
  ggplot(aes(x = log(lbxbmn), y = wtsh2yr)) +
  geom_point()
# maybe 3 outliers? 

```

### Data Distribution: Methyl Mercury

```{r speciated blood Hg check distributions, include=FALSE}
 
# check the distribution and normality of the data and identify outliers for continuous variables
# "svyhist" creates histograms accounting for survey weights 
 
## Methyl Hg
svyhist(~lbxbgm,
        blood.hg.svy, 
        main = "Survey weighted average blood MeHg", col = "yellow")
# right-skewed 

# meHg log transformed
svyhist(~log(lbxbgm),
        blood.hg.svy,  
        main = "Survey weighted log(average blood MeHg)", col = "yellow")
# still not quite normal.... 

```

```{r speciated blood Hg skewness, eval=FALSE, include=FALSE}

# methyl Hg skewness/kurtosis
skewness(hg1516_sub$lbxbgm)
kurtosis(hg1516_sub$lbxbgm)

# log transformed methyl Hg skewness/kurtosis
skewness(log(hg1516_sub$lbxbgm))
kurtosis(log(hg1516_sub$lbxbgm))

```

```{r speciated blood Hg qqplots, eval=FALSE, include=FALSE}

# methyl Hg qqplot
qqnorm(hg1516_sub$lbxbgm)
qqline(hg1516_sub$lbxbgm)

# log transformed methyl Hg qqplot
qqnorm(log(hg1516_sub$lbxbgm))
qqline(log(hg1516_sub$lbxbgm))

```

```{r speciated blood Hg check impact of influential outliers, eval=FALSE, include=FALSE}


# plot the survey weight against the variable to determine which extreme values are outliers
hg1516_sub %>% 
  ggplot(aes(x = log(lbxbgm), y = wtsh2yr)) +
  geom_point()

# what should this plot look like?? 
# should I be concerned about outliers, because it looks like those with very high blood Pb have lower weights


```

### Data Distribution: Urinary Mercury

{we are not analyzing urinary mercury, ignore}

```{r urinary Hg check distributions, eval=FALSE, include=FALSE}

# check the distribution and normality of the data and identify outliers for continuous variables

# adjusted urinary Hg
svyhist(~urxuhg_adj,
        urine.hg.svy, 
        main = "Survey weighted average urinary Hg, creatinine-adjusted", col = "yellow")
# right-skewed

# log-transformed adjusted urinary Hg
svyhist(~log(urxuhg_adj),
        urine.hg.svy, 
        main = "Survey weighted log(average creatinine-adjusted urinary Hg)", col = "yellow")
# normal 

```

```{r urinary Hg skewness, eval=FALSE, include=FALSE}

# urinary Hg, adjusted for creatinine
skewness(uhg1516_sub$urxuhg_adj)
kurtosis(uhg1516_sub$urxuhg_adj)
# log(urinary Hg, adjusted for creatinine)
skewness(log(uhg1516_sub$urxuhg_adj))
kurtosis(log(uhg1516_sub$urxuhg_adj))

# log adjusted looks great! 

```

```{r urinary Hg qqplots, eval=FALSE, include=FALSE}

# urinary Hg qqplot
qqnorm(uhg1516_sub$urxuhg_adj) 
qqline(uhg1516_sub$urxuhg_adj)

# log transformed qqplot, urinary Hg
qqnorm(log(uhg1516_sub$urxuhg_adj)) 
qqline(log(uhg1516_sub$urxuhg_adj))

```

```{r urinary Hg describe impact of influential outliers, eval=FALSE, include=FALSE}

# assess if there are influential / extreme outliers

uhg1516_sub %>% 
  ggplot(aes(x = log(urxuhg_adj), y = wtsa2yr)) +
  geom_point()
# maybe one outlier... 

```

### Data Distribution: Urinary Arsenic

{not going to analyze arsenic, ignore}

```{r urinary As check distributions, eval=FALSE, include=FALSE}

# check the distribution and normality of the data and identify outliers for continuous variables

## Total Arsenic
svyhist(~urxuas, # already adjusted for creatinine in this dataset 
        arsenic.svy,
        main = "Survey weighted average urinary As, creatinine-adjusted", col = "blue")
 
# log transformed
svyhist(~log(urxuas), 
        arsenic.svy,
        main = "Survey weighted log(average urinary As, creatinine-adjusted)", col = "blue")
## looks much more normal 

## DMA
svyhist(~urxudma, # already adjusted for creatinine in this dataset 
        arsenic.svy,
        main = "Survey weighted average urinary DMA, creatinine-adjusted", col = "red")
# right-skewed 

# log transformed
svyhist(~log(urxudma),
        arsenic.svy,
        main = "Survey weighted log(average urinary DMA, creatinine-adjusted)", col = "red")
# normal 

```

```{r urinary As skewness, eval=FALSE, include=FALSE}

# adjusted arsenic
skewness(uas1516_sub$urxuas)
kurtosis(uas1516_sub$urxuas)

# log(adjusted arsenic)
skewness(log(uas1516_sub$urxuas))
kurtosis(log(uas1516_sub$urxuas)) 
# log looks much better! still some extremes at the tails though 

###
 
# adjusted DMA 
skewness(uas1516_sub$urxudma)
kurtosis(uas1516_sub$urxudma)

# log(adjusted DMA)
skewness(log(uas1516_sub$urxudma))
kurtosis(log(uas1516_sub$urxudma))

# looks much better!  
 
```

```{r urinary As and DMA qqplots, eval=FALSE, include=FALSE}

# total As
qqnorm(uas1516_sub$urxuas)
qqline(uas1516_sub$urxuas) 
# log (adjusted) total As
qqnorm(log(uas1516_sub$urxuas))
qqline(log(uas1516_sub$urxuas)) 

# DMA
qqnorm(uas1516_sub$urxudma)
qqline(uas1516_sub$urxudma) 
# log (adjusted) DMA
qqnorm(log(uas1516_sub$urxudma))
qqline(log(uas1516_sub$urxudma))


```

```{r urinary As describe impact of influential outliers, eval=FALSE, include=FALSE}

# total As 
uas1516_sub %>% 
  ggplot(aes(x = log(urxuas), y = wtsa2yr)) +
  geom_point()

# DMA
uas1516_sub %>% 
  ggplot(aes(x = log(urxudma), y = wtsa2yr)) +
  geom_point()

# both look ok

```

## Descriptive Statistics

The log-transformed data looks better for Pb, Mn, as well as urinary Hg, total As, and DMA. **Thus, for these variables, we will use the log-transformed average for statistical tests, such as models and using the svyby function.** 

Below are the geometric mean levels (and 95% CIs) of blood Pb, Cd, Mn, and Hg (total and meHg), as well as urinary total As and DMA in the US population (accounting for survey weights and design):

### Blood Pb

```{r blood Pb only}
 
### OVERALL 

# Count number of males and females in this dataset
table(nh1516_sub$sex)
100*(svymean(~sex, blood.svy)) # weighted percentage of individuals by sex
#           mean     SE
# sexMale   48.802 0.0104
# sexFemale 51.198 0.0104

# overall population geometric mean Pb and 95% CI
pb_log_mean <-
  svymean(~log(lbxbpb),
          blood.svy) 

## Geometric mean, overall blood Pb 
exp(pb_log_mean)[1]

## 95% Confidence Intervals
# Geometric mean lower 95% confidence interval
exp(pb_log_mean[1] - 1.96 * sqrt(attr(pb_log_mean, "var")))
# Geometric mean upper 95% confidence interval
exp(pb_log_mean[1] + 1.96 * sqrt(attr(pb_log_mean, "var")))

### BY SEX

# svyby is the function that will compute summary statistics of continuous variables within your "svydesign", across a cateogrical variable. In this case, we want average log transformed blood metal values separately for males and females. We specify "svymean" at the end of the command line to tell the command that we want the average means.

# Pb by sex
svyby(~log(lbxbpb),
      by = ~sex,
      blood.svy,
      svymean, 
      ci = TRUE)

# Males
# Geometric mean and 95% CI
exp(-0.0825263) # 0.9207872 ug/dL, geometric mean for males
exp(-0.0825263 - (1.96 * 0.02973103)) # lower 95% CI
exp(-0.0825263 + (1.96 * 0.02973103)) # upper 95% CI

# Females
# Geometric mean and 95% CI
exp(-0.3077383) # 0.7351077 ug/dL, geometric mean for females
exp(-0.3077383 - (1.96 * 0.03711817)) # lower 95% CI
exp(-0.3077383 + (1.96 * 0.03711817)) # upper 95% CI
# note that the exponentiated form of the mean of a log-transformed variable is the GEOMETRIC MEAN! 

# To determine if this difference is statistically significnat, I do a t-test because I am comparing the mean of a continuous variable across two groups 
tt_lbxbpb <- 
  svyttest(log(lbxbpb)~sex,
           blood.svy)
 
tt_lbxbpb
# p-value = 2.58e-05, so the difference in mean blood Pb levels across males and females is significant 
# note that lbxbpb is in the units ug/dL whereas the other blood metals are in ug/L
 
```

Graph the results:

```{r plot difference in blood Pb by sex}
 
pb_sex_means <- read.csv("pb_sex_means.csv")  
 
pb_plot <-
pb_sex_means %>% 
  ggplot(aes(x = Sex, 
             y = geo_mean,
             fill = Sex)) + 
  geom_point(aes(shape = Sex),
             size = 3) +
  geom_errorbar(aes(ymin = lower, # change for different metals
                    ymax = upper),
                    width = 0.2,
                    position = position_dodge(0.9)) +
  geom_signif(comparisons = list(c("Female", "Male")), annotations = "***") +
  ggtitle("Blood Pb Levels") +
  labs(x = "Sex",
       y = "Blood Pb (ug/dL)") +
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(legend.position = "none") + 
  font("title", size = 16, face = "bold") +
  font("xlab", size = 14) +
  font("ylab", size = 14) +
  rremove("x.grid")
#  + ylim(0,1)

pb_plot

  #stat_compare_means(comparisons = my_comparisons)+ # Add pairwise comparisons p-value
  #stat_compare_means(label.y = 50)                  # Add global p-value
  
```

### Blood Cd

```{r blood Cd only}

# Count number of males and females in this dataset
table(nh1516_sub$sex)
100*(svymean(~sex, blood.svy)) # weighted percentage of individuals by sex 
#           mean     SE 
# sexMale   48.802 0.0104
# sexFemale 51.198 0 .0104
 
### OVERALL 

# overall population geometric mean and 95% CI
cd_log_mean <-
  svymean(~log(lbxbcd), # ok to use log, or log10?? ASK 
          blood.svy) 

## Geometric mean, overall blood Cd 
exp(cd_log_mean)[1]

## 95% Confidence Intervals
# Geometric mean lower 95% confidence interval
exp(cd_log_mean[1] - 1.96 * sqrt(attr(cd_log_mean, "var")))
# Geometric mean upper 95% confidence interval
exp(cd_log_mean[1] + 1.96 * sqrt(attr(cd_log_mean, "var")))

### BY SEX 

# Cd by sex
svyby(~log(lbxbcd),
      by = ~sex,
      blood.svy,
      svymean)

# Males
# Geometric mean and 95% CI
exp(-1.537352) # 0.2149495 ug/L, geometric mean for males
exp(-1.537352 - (1.96 * 0.03148460)) # lower 95% CI
exp(-1.537352 + (1.96 * 0.03148460)) # upper 95% CI

# Females
# Geometric mean and 95% CI
exp(-1.337665) # 0.2624578 ug/L, geometric mean for females
exp(-1.337665 - (1.96 * 0.03405788)) # lower 95% CI
exp(-1.337665 + (1.96 * 0.03405788)) # upper 95% CI
# note that the exponentiated form of the mean of a log-transformed variable is the GEOMETRIC MEAN! 

# To determine if this difference is statistically significnat, I do a t-test because I am comparing the mean of a continuous variable across two groups 
tt_lbxbcd <-
  svyttest(log(lbxbcd)~sex,
           blood.svy)

tt_lbxbcd
# p-value = 1.774e-05, so the difference in mean blood Cd levels across males and females is significant
  
```

Graph the results: 

```{r plot Cd difference by sex}

cd_sex_means <- read.csv("cd_sex_means.csv") 

cd_plot <-  
  cd_sex_means %>%  
  ggplot(aes(x = Sex, 
             y = geo_mean,
             fill = Sex)) + 
  geom_point(aes(shape = Sex),
             size = 3) +
  geom_errorbar(aes(ymin = lower, # change for different metals
                    ymax = upper),
                    width = 0.2,
                    position = position_dodge(0.9)) +
  geom_signif(comparisons = list(c("Female", "Male")), annotations = "***") +
  labs(title = "Blood Cd Levels", # edit labels for diff graphs
       x = "Sex",
       y = "Blood Cd (ug/L)") +
  theme(legend.position = "none") +
  font("title", size = 16, face = "bold") +
  font("xlab", size = 14) +
  font("ylab", size = 14) +
  rremove("x.grid")
#  + ylim(0,1)
 
cd_plot

```

### Blood Mn 

```{r blood Mn only}

# Count number of males and females in this dataset
table(nh1516_sub$sex)
100*(svymean(~sex, blood.svy)) # weighted percentage of individuals by sex
#           mean     SE
# sexMale   48.802 0.0104
# sexFemale 51.198 0.0104

### OVERALL

# overall population geometric mean and 95% CI
mn_log_mean <-
  svymean(~log(lbxbmn), 
          blood.svy) 

## Geometric mean, overall blood Mn
exp(mn_log_mean)[1]

## 95% Confidence Intervals
# Geometric mean lower 95% confidence interval
exp(mn_log_mean[1] - 1.96 * sqrt(attr(mn_log_mean, "var")))
# Geometric mean upper 95% confidence interval
exp(mn_log_mean[1] + 1.96 * sqrt(attr(mn_log_mean, "var")))

### BY SEX 

# Mn by sex
svyby(~log(lbxbmn),
      by = ~sex,
      blood.svy,
      svymean)

# Males
# Geometric mean and 95% CI
exp(2.196282) # 8.991521 ug/L, geometric mean for males
exp(2.196282 - (1.96 * 0.01337830)) # lower 95% CI
exp(2.196282 + (1.96 * 0.01337830)) # upper 95% CI

# Females
# Geometric mean and 95% CI
exp(2.322047) # 10.19653 ug/L, geometric mean for females
exp(2.322047 - (1.96 * 0.01144469)) # lower 95% CI
exp(2.322047 + (1.96 * 0.01144469)) # upper 95% CI
# note that the exponentiated form of the mean of a log-transformed variable is the GEOMETRIC MEAN! 

# To determine if this difference is statistically significnat, I do a t-test because I am comparing the mean of a continuous variable across two groups 
tt_lbxbmn <-
  svyttest(log(lbxbmn)~sex,
           blood.svy)

tt_lbxbmn
# p-value = 1.774e-05, so the difference in mean blood Cd levels across males and females is significant
 
```

Graph the results: 

```{r plot Mn difference by sex}

mn_sex_means <- read.csv("mn_sex_means.csv")

mn_plot <-
mn_sex_means %>% 
  ggplot(aes(x = Sex, 
             y = geo_mean,
             fill = Sex)) + 
  geom_point(aes(shape = Sex),
             size = 3) +
  geom_errorbar(aes(ymin = lower, # change for different metals
                    ymax = upper),
                    width = 0.2,
                    position = position_dodge(0.9)) +
  geom_signif(comparisons = list(c("Female", "Male")), annotations = "***") +
  labs(title = "Blood Mn Levels", # edit labels for diff graphs
       x = "Sex",
       y = "Blood Mn (ug/L)") +
  theme(legend.position = "none") +
  font("title", size = 16, face = "bold") +
  font("xlab", size = 14) +
  font("ylab", size = 14) +
  rremove("x.grid")
# + ylim(0,11)

mn_plot

```

### Speciated Blood Hg

The percentage of participants with values < LOD is too high for inorganic blood Hg and ethyl blood Hg. Thus, I will only be analyzing total Hg and MeHg in blood.

#### Total Hg

```{r total blood Hg}

### OVERALL 

# Count number of males and females in this dataset
table(nh1516_sub$sex)
100*(svymean(~sex, blood.svy)) # weighted percentage of individuals by sex
#            mean     SE
# sexMale   48.802 0.0104
# sexFemale 51.198 0.0104

# overall population geometric mean and 95% CI
total_hg_log_mean <-
  svymean(~log(lbxthg), 
          blood.svy) 

## Geometric mean, total blood Hg
exp(total_hg_log_mean)[1]

## 95% Confidence Intervals
# Geometric mean lower 95% confidence interval
exp(total_hg_log_mean[1] - 1.96 * sqrt(attr(total_hg_log_mean, "var")))
# Geometric mean upper 95% confidence interval
exp(total_hg_log_mean[1] + 1.96 * sqrt(attr(total_hg_log_mean, "var")))

### BY SEX

# total Hg by sex
svyby(~log(lbxthg),
      by = ~sex,
      blood.svy,
      svymean)

# Males
# Geometric mean and 95% CI
exp(-0.3867216) # 0.6792802 ug/L, geometric mean for males
exp(-0.3867216 - (1.96 * 0.04231005)) # lower 95% CI
exp(-0.3867216 + (1.96 * 0.04231005)) # upper 95% CI

# Females
# Geometric mean and 95% CI
exp(-0.3890153) # 0.6777239 ug/L, geometric mean for females
exp(-0.3890153 - (1.96 * 0.05030650)) # lower 95% CI
exp(-0.3890153 + (1.96 * 0.05030650)) # upper 95% CI
# note that the exponentiated form of the mean of a log-transformed variable is the GEOMETRIC MEAN! 

# To determine if this difference is statistically significnat, I do a t-test because I am comparing the mean of a continuous variable across two groups 
tt_lbxthg <-
  svyttest(log(lbxthg)~sex,
           blood.svy) 

tt_lbxthg
# p-value = 0.998, so the difference in mean blood total Hg levels across males and females is NOT significant 

```

#### Methyl Mercury

```{r blood methyl Hg}

### OVERALL  

# Count number of males and females in this dataset
table(hg1516_sub$sex)
100*(svymean(~sex, blood.hg.svy)) # weighted percentage of individuals by sex
#            mean     SE
# sexMale   48.764 0.0104
# sexFemale 51.236 0.0104

# overall population geometric mean and 95% CI
mehg_log_mean <-
  svymean(~log(lbxbgm), 
          blood.hg.svy) 

## Geometric mean, meHg
exp(mehg_log_mean)[1]

## 95% Confidence Intervals
# Geometric mean lower 95% confidence interval
exp(mehg_log_mean[1] - 1.96 * sqrt(attr(mehg_log_mean, "var")))
# Geometric mean upper 95% confidence interval
exp(mehg_log_mean[1] + 1.96 * sqrt(attr(mehg_log_mean, "var")))

### BY SEX

# meHg by sex
svyby(~log(lbxbgm),
      by = ~sex,
      blood.hg.svy,
      svymean)

# Males
# Geometric mean and 95% CI
exp(-0.8460826) # 0.4290926 ug/L, geometric mean for males
exp(-0.8460826 - (1.96 * 0.05833375)) # lower 95% CI
exp(-0.8460826 + (1.96 * 0.05833375)) # upper 95% CI

# Females
# Geometric mean and 95% CI
exp(-0.9186819) # 0.3990447 ug/L, geometric mean for females
exp(-0.9186819 - (1.96 * 0.07721073)) # lower 95% CI
exp(-0.9186819 + (1.96 * 0.07721073)) # upper 95% CI
# note that the exponentiated form of the mean of a log-transformed variable is the GEOMETRIC MEAN! 

# To determine if this difference is statistically significnat, I do a t-test because I am comparing the mean of a continuous variable across two groups 
tt_lbxbgm <-
  svyttest(log(lbxbgm)~sex,
           blood.hg.svy)

tt_lbxbgm
# p-value = 0.2369, so the difference in mean blood meHg levels across males and females is NOT significant

```

Graph the results: 

```{r Total Hg and meHg graph}

# upload dataset with the means and 95% CIs (pasted manually into a csv)  
hg_sex_means <- read.csv("hg_sex_means.csv")   
 
# plot 
hg_plot <- 
hg_sex_means %>% 
  ggplot(aes(x = Sex, 
             y = geo_mean, 
             fill = Type)) +
  geom_point(aes(color = Type,
                 shape = Sex),
                 size = 3,
                 position = "dodge") +
  geom_errorbar(aes(color = Type,
                    ymin = lower, # change for different metalas
                    ymax = upper),
                    width = 0.2) +
  geom_signif(comparisons = list(c("Female", "Male")), annotations = "NS") +
  labs(title = "Blood Hg Levels", # edit labels for diff graphs
       x = "Sex",
       y = "Blood Hg (ug/L)") +
  font("title", size = 16, face = "bold") +
  font("xlab", size = 14) +
  font("ylab", size = 14) +
  font("legend.title", size = 14, face = "bold") + 
  font("legend.text", size = 12) +
  rremove("x.grid")
 # + ylim(0,1)

hg_plot

```

```{r export plots}

## View Plots 
pb_plot  
cd_plot
mn_plot
hg_plot

#########################

## Export Plots
### Pb 
pdf(file = "./figures/pb-by-sex.pdf")
  pb_plot
dev.off()

### Cd 
pdf(file = "./figures/cd-by-sex.pdf")
  cd_plot
dev.off()

### Mn 
pdf(file = "./figures/mn-by-sex.pdf")
  mn_plot
dev.off()

### Hg, Total and MeHg 
pdf(file = "./figures/hg-by-sex.pdf")
  hg_plot
dev.off()

```

Combine plots into one figure: 

```{r combine plots to figure 1}

pb_plot <- ggarrange(pb_plot + rremove("x.text"), 
                     labels = c("A"))
cd_plot <- ggarrange(cd_plot + rremove("x.text"),
                     labels = c("B"))
mn_plot <- ggarrange(mn_plot + rremove("x.text"),
                     labels = c("C"))
hg_plot <- ggarrange(hg_plot + rremove("x.text"),
                     labels = c("D"))

figure_1 <- (pb_plot + cd_plot) / (mn_plot + hg_plot)


figure_1 <- ggarrange(pb_plot + rremove("x.text"), 
                      cd_plot + rremove("x.text"),
                      mn_plot + rremove("x.text"), 
                      hg_plot + rremove("x.text"),
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2) 

annotate_figure(figure_1,
                bottom = text_grob("Data source: NHANES 2015-2016",
                                   face = "italic", size = 12))

figure_1
# do we like consistent y axis better?? 

```

##### Export Figure 1 graph

```{r export fig 1}

pdf(file = "./figures/figure-1-blood levels.pdf")
  figure_1
dev.off()
 
# edit as needed 

```

### Urinary Hg

**The % of participants < LOD is too high to be meaningful!**

```{r urinary Hg, eval=FALSE, include=FALSE}

### OVERALL 

# Count number of males and females in this dataset
table(uhg1516_sub$sex)
100*(svymean(~sex, urine.hg.svy)) # weighted percentage of individuals by sex
#           mean     SE
# sexMale   48.82 0.0142
# sexFemale 51.18 0.0142


# overall population geometric mean and 95% CI
uhg_log_mean <-
  svymean(~log(urxuhg_adj), 
          urine.hg.svy) 

## Geometric mean, meHg
exp(uhg_log_mean)[1]

## 95% Confidence Intervals
# Geometric mean lower 95% confidence interval
exp(uhg_log_mean[1] - 1.96 * sqrt(attr(uhg_log_mean, "var")))
# Geometric mean upper 95% confidence interval
exp(uhg_log_mean[1] + 1.96 * sqrt(attr(uhg_log_mean, "var")))

### BY SEX

# meHg by sex
svyby(~log(urxuhg_adj),
      by = ~sex,
      urine.hg.svy,
      svymean)

# Males
# Geometric mean and 95% CI
exp(-15.65253) # 0.4281462 ug/L, geometric mean for males
exp(-15.65253 - (1.96 * 0.03096009)) # lower 95% CI
exp(-15.65253 + (1.96 * 0.03096009)) # upper 95% CI

# Females
# Geometric mean and 95% CI
exp(-15.27463) # 0.3990447 ug/L, geometric mean for females
exp(-15.27463 - (1.96 * 0.03621319)) # lower 95% CI
exp(-15.27463 + (1.96 * 0.03621319)) # upper 95% CI
# note that the exponentiated form of the mean of a log-transformed variable is the GEOMETRIC MEAN! 

# To determine if this difference is statistically significnat, I do a t-test because I am comparing the mean of a continuous variable across two groups 
tt_urxuhg_adj <-
  svyttest(log(urxuhg_adj)~sex,
           urine.hg.svy)

tt_urxuhg_adj
# p-value = 5.227e-07, so the difference in urinary Hg levels across males and females is significant


```

## Differences across age groups

The exposures and body burdens of these various metals often change over the life course, from childhood through elderly years. Do sex differences exist at certain windows across the life course that are otherwise masked when looking at mean metal levels averaged across all ages? 

To explore this, we will create a new categorical variable, "life_stage," that indicates whether an individual is in his or her child, adolescent, adult, or senior years. 

**Question:** Accounting for survey design, what are the mean blood metal levels of 2015/2016 US males and females across childhood, adolescence, adulthood, and senior years? 

We define "child" as age < 12 years,
"adolescent" as age 12-21 years,
"adult" as age 22-65 years, 
and "elderly" as age > 65 years.

```{r differences across life stages}
 
## create new life stage variable 
nh1516_sub <- 
  nh1516_sub %>% 
  mutate(life_stage =
           ifelse(age < 12, "Child",
           ifelse(age %in% 12:21, "Adolescent",
           ifelse(age %in% 22:65, "Adult",
                  "Elderly")))) %>% 
  mutate(life_stage = as.factor(life_stage))

# relevel the factors to be in chronological order of life stages
nh1516_sub$life_stage <- fct_relevel(nh1516_sub$life_stage, c("Child", "Adolescent", "Adult", "Elderly"))
  
# Re-set the survey design
# NOTE: We always have to re-set the survey design after we create any new variable.
nhanes.svy <- svydesign(ids = ~sdmvpsu,
                        strata = ~sdmvstra,
                        weights = ~wtsh2yr,
                        nest = TRUE,
                        data = nh1516_sub)

## Calculate geometric means across sex and life stages
svyby(~log(lbxbpb)+log(lbxbcd)+log(lbxthg)+log(lbxbmn), # continuous variable
      by = ~sex+life_stage, # groups
      nhanes.svy, # the ”svydesign” object 
      svymean)  # the function you want 

  svyby(~log(lbxbpb)+log(lbxbcd)+log(lbxthg)+log(lbxbmn), 
      by = ~sex+life_stage, 
      nhanes.svy, 
      svymean) %>%  
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = F) 
# put these means into a table and exponentiate them
  # the results are saved as the file, life_sex_means.XLSX 
  
# Do the same for the hg1516_sub data (for methyl Hg only)
  hg1516_sub <-
  hg1516_sub %>% 
  mutate(life_stage =
           ifelse(age < 12, "Child",
           ifelse(age %in% 12:21, "Adolescent",
           ifelse(age %in% 22:65, "Adult",
                  "Elderly")))) %>% 
  mutate(life_stage = as.factor(life_stage))
  
# relevel the factors to be in chronological order of life stages
hg1516_sub$life_stage <- fct_relevel(hg1516_sub$life_stage, c("Child", "Adolescent", "Adult", "Elderly"))

# Re-set the survey design
# NOTE: We always have to re-set the survey design after we create any new variable.
blood.hg.svy <- svydesign(ids = ~sdmvpsu,
                        strata = ~sdmvstra,
                        weights = ~wtsh2yr,
                        nest = TRUE,
                        data = hg1516_sub)

## Calculate geometric means across sex and life stages
svyby(~log(lbxbgm), # continuous variable
      by = ~sex+life_stage, # groups
      blood.hg.svy, # the ”svydesign” object 
      svymean)  # the function you want 

  svyby(~log(lbxbgm), 
      by = ~sex+life_stage, 
      blood.hg.svy, 
      svymean) %>%  
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = F) 
# add this to the life means xlsx file (done)
  
# Ns per group
nh1516_sub %>% 
  count(sex == "Female" & life_stage == "Elderly")
## Males
# N = 926 Male Child
# N = 309 Male Adolescent
# N = 966 Male Adult
# N = 287 Male Elderly
## Females
# N = 887 Female Child
# N = 307 Female Adolescent
# N = 1014 Female Adult
# N = 291 Female Elderly
  
```

Graph the results: 

```{r plot differences across life stages}
 
# first, create a new dataset from the life_means_table data
# import data 
life_means_data <-
  read_csv("life_sex_means.csv") %>% 
  mutate(life_stage = as.factor(life_stage)) %>% 
  select(Sex:upper) 

life_means_data$life_stage <-
  factor(life_means_data$life_stage, levels = c("Child", "Adolescent", "Adult", "Elderly"))


# Lead
pb_life_plot <- 
life_means_data %>% 
  filter(metal == "lbxbpb") %>% 
  ggplot(aes(x = life_stage, 
             y = geo_mean,  # change for different metals
             fill = Sex)) +
  geom_point(aes(color = Sex,
                 shape = Sex), 
                 position = position_dodge(0.4)) +
  geom_errorbar(aes(color = Sex,
                    ymin = lower, # change for different metals
                    ymax = upper),
                    width = 0.2,
                    position = position_dodge(0.4)) +
#  geom_signif(comparisons = list(c("Female", "Male"))) +
  labs(title = "Pb", # edit labels for diff graphs
       x = "Life Stage",
       y = "Blood Pb (ug/dL)") +
  theme(legend.position = "none") +
  font("title", size = 16, face = "bold") +
  font("xlab", size = 14) +
  font("ylab", size = 14)

# Cd
cd_life_plot <- 
life_means_data %>% 
  filter(metal == "lbxbcd") %>% 
  ggplot(aes(x = life_stage, 
             y = geo_mean,  # change for different metals
             fill = Sex)) +
  geom_point(aes(color = Sex,
                 shape = Sex), 
                 position = position_dodge(0.4)) +
  geom_errorbar(aes(color = Sex,
                    ymin = lower, # change for different metalas
                    ymax = upper),
                    width = 0.2,
                    position = position_dodge(0.4)) +
  #geom_signif(comparisons = list(c("Female", "Male"))) +
  labs(title = "Cd", # edit labels for diff graphs
       x = "Life Stage",
       y = "Blood Cd (ug/L)") +
  theme(legend.position = "none") +
  font("title", size = 16, face = "bold") +
  font("xlab", size = 14) +
  font("ylab", size = 14)

# Mn
mn_life_plot <- 
life_means_data %>% 
  filter(metal == "lbxbmn") %>% 
  ggplot(aes(x = life_stage, 
             y = geo_mean,  # change for different metals
             fill = Sex)) +
  geom_point(aes(color = Sex,
                 shape = Sex), 
                 position = position_dodge(0.4)) +
  geom_errorbar(aes(color = Sex,
                    ymin = lower, # change for different metalas
                    ymax = upper),
                    width = 0.2,
                    position = position_dodge(0.4)) +
  #geom_signif(comparisons = list(c("Female", "Male"))) +
  labs(title = "Mn", # edit labels for diff graphs
       x = "Life Stage",
       y = "Blood Mn (ug/L)") +
  theme(legend.position = "none") +
  font("title", size = 16, face = "bold") +
  font("xlab", size = 14) +
  font("ylab", size = 14)

# Total Hg
hg_life_plot <-
life_means_data %>% 
  filter(metal == "lbxthg") %>% 
  ggplot(aes(x = life_stage, 
             y = geo_mean,  # change for different metals
             fill = Sex)) +
  geom_point(aes(color = Sex,
                 shape = Sex), 
                 position = position_dodge(0.4)) +
  geom_errorbar(aes(color = Sex,
                    ymin = lower, # change for different metalas
                    ymax = upper),
                    width = 0.2,
                    position = position_dodge(0.4)) +
  #geom_signif(comparisons = list(c("Female", "Male"))) +
  labs(title = "Hg (Total)", # edit labels for diff graphs
       x = "Life Stage",
       y = "Total Blood Hg (ug/L)") +
  theme(legend.position = "none") +
  font("title", size = 16, face = "bold") +
  font("xlab", size = 14) +
  font("ylab", size = 14)

# MeHg 
mehg_life_plot <-
life_means_data %>% 
  na.omit() %>% 
  filter(metal == "lbxbgm") %>% 
  ggplot(aes(x = life_stage, 
             y = geo_mean,  # change for different metals
             fill = Sex)) +
  geom_point(aes(color = Sex,
                 shape = Sex), 
                 position = position_dodge(0.4)) +
  geom_errorbar(aes(color = Sex,
                    ymin = lower, # change for different metals 
                    ymax = upper),
                    width = 0.2,
                    position = position_dodge(0.4)) + 
  labs(title = "MeHg", # edit labels for diff graphs
       x = "Life Stage",
       y = "Blood MeHg (ug/L)") +
  theme(legend.position = "right") +
  font("title", size = 16, face = "bold") +
  font("xlab", size = 14) +
  font("ylab", size = 14) + 
  font("legend.title", size = 14, face = "bold") + 
  font("legend.text", size = 12)

```

Assess # below LOD by age/sex: 

```{r assess LODs}

nh1516_sub %>% 
  filter(sex == "Female" & life_stage == "Elderly") %>% 
  count(lbdthglc == 1)

# for Pb: lbdbpblc
# for Cd: lbdbcdlc
# for Mn: lbdbmnlc
# for total Hg: lbdthglc

## for methyl Hg: 
hg1516_sub %>% 
  filter(sex == "Female" & life_stage == "Elderly") %>% 
  count(lbdbgmlc == 1)

```

Are these differences seen across sex and age group significant? 

```{r ANOVAs}

# use ANOVA because I am comparing the mean of a continuous variable across two categorical variables (sex and age group)

# Pb
model1 <- svyglm(log(lbxbpb)~life_stage+sex,
                 design = nhanes.svy)

summary(model1) # gives overall p value
anova(model1, 
      type = "II")

residuals(model1) %>% 
  histogram()

# Cd
model2 <- svyglm(log(lbxbcd)~life_stage+sex,
                 design = nhanes.svy)

summary(model2)
anova(model2)
  
# Mn
model3 <- svyglm(log(lbxbmn)~life_stage+sex,
                 design = nhanes.svy)

summary(model3)
anova(model3)
  
# Total Hg
model4 <- svyglm(log(lbxthg)~life_stage+sex,
                 design = nhanes.svy)

summary(model4)
anova(model4)

# MeHg
model5 <- svyglm(log(lbxbgm)~life_stage+sex,
                 design = blood.hg.svy)
  
summary(model5)
anova(model5)

#anova(model1, model2)
#anova(model1, model2, method="Wald")

```

```{r view and export lifecourse plots}

## View
pb_life_plot
cd_life_plot
mn_life_plot 
hg_life_plot
mehg_life_plot 

## Export 
### Pb 
pdf(file = "./figures/pb-lifecourse.pdf")
  pb_life_plot
dev.off()

### Cd
pdf(file = "./figures/cd-lifecourse.pdf")
  cd_life_plot
dev.off()

### Mn
pdf(file = "./figures/mn-lifecourse.pdf")
  mn_life_plot
dev.off()

### Total Hg 
pdf(file = "./figures/hg-lifecourse.pdf")
  hg_life_plot
dev.off()

### MeHg 
pdf(file = "./figures/mehg-lifecourse.pdf")
  mehg_life_plot
dev.off()


```


```{r combine plots into figure2}

pb_life_plot <-
  ggarrange(pb_life_plot, labels = c("A"))
cd_life_plot <-
  ggarrange(cd_life_plot, labels = c("B"))
mn_life_plot <- 
  ggarrange(mn_life_plot, labels = c("C"))
hg_life_plot <-
  ggarrange(hg_life_plot, labels = c("D"))
mehg_life_plot <- 
  ggarrange(mehg_life_plot, labels = c("E"))

figure_2 <- (pb_life_plot + cd_life_plot + mn_life_plot) / (hg_life_plot + mehg_life_plot)

figure_2
# do we like consistent y axis better?? 

```

Export figure 2:

```{r}

pdf(file = "./figures/figure-2-age-sex.pdf")
  figure_2
dev.off()

```


```{r lead ages 1-2}

# Lead, Ages 1-2

## Q: How can I calculate and graph the mean if the stratum has only one PSU at stage 1??
# A: Use "lonely adjust" and note that this may not be representative of the true population mean 
## lead in ages 1-2
nh1516_young <-
  nh1516_sub %>% 
  filter(age == 1 | age == 2)

nhanes.svy.young <- svydesign(ids = ~sdmvpsu, # cluster IDs
                        strata = ~sdmvstra, # strata IDs
                        weights = ~wtsh2yr, # individual weights, subsample descriptions and weights are found in the specific datafiles downloaded from NHANES website
                        nest = TRUE,
                        data = nh1516_young) # call the dataframe 

svyby(~log(lbxbpb), # continuous variable
      by = ~sex, # groups
      nhanes.svy.young, # the ”svydesign” object 
      svymean, # the function you want %>% 
      ci = TRUE)  
# Note that in the setup chunk, the survey options is set so that survey.lonely.psu = "adjust" 
# this means that even though this data only comes from one PSU, the code does not give an error
# we use "adjust" to center the stratum at the population mean rather than the stratum mean
# the data for the single-PSU stratum are centered at the sample grand mean rather than the stratum mean. This is conservative.

tt_pb_young <-
  svyttest(log(lbxbpb)~sex,
           nhanes.svy.young)

tt_pb_young

young_pb_means <- read_csv("young_pb_means.csv")

young_pb_plot <- 
young_pb_means %>% 
  ggplot(aes(x = Sex, 
             y = lbxbpb,
             fill = Sex)) + 
  geom_point(aes(shape = Sex)) +
  geom_errorbar(aes(ymin = lower, # change for different metals
                    ymax = upper),
                    width = 0.2,
                    position = position_dodge(0.9)) +
  geom_signif(comparisons = list(c("Female", "Male")), annotations = "p=0.4977") +
  labs(title = "Blood Pb in Persons Aged 1-2 Years", # edit labels for diff graphs
       x = "Sex",
       y = "Blood Pb (ug/dL)",
       caption = "NHANES 2015/2016 data, Ages 1-2 years") +
    font("title", size = 16, face = "bold") +
  font("xlab", size = 14) +
  font("ylab", size = 14) + 
  font("legend.title", size = 14, face = "bold") + 
  font("legend.text", size = 12)
  

# p-value = 0.4977 so the difference between males and females at this young age is not apparent, although this was just from one PSU so may not be representative of this segment of the population 

nh1516_young %>% 
  count(sex == "Female")

```

```{r export figure 3}

young_pb_plot

####
pdf(file = "./figures/figure3-young-pb.pdf")
  young_pb_plot
dev.off()

```


--Extra Stuff--

```{r urine mercury statistics and graphing, eval=FALSE, include=FALSE}

## svymean: Computes means and SEs for survey data
svymean(~urxuhg, # continuous variable(s)
        uhg.svy) # the ”svydesign” object

# put results into a table
urinary_hg_table <-
  svymean(~urxuhg, nhanes.svy) %>% 
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = F) 

##############################################################
## By Sex

## svyby: Survey stats on subsets of data (or, survey stats across levels of factors)
svyby(~urxuhg, # continuous variable
      by = ~sex, # groups
      uhg.svy, # the ”svydesign” object 
      svymean)  # the function you want %>% 

# put into a table
sex_urxhg_table <-
  svyby(~urxuhg, # continuous variable
      by = ~sex, # groups
      uhg.svy, # the ”svydesign” object 
      svymean) %>%  # the function you want %>% 
  kable() %>% 
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = F) 

##############################################################
# T Test

## Is the difference across males and females significant?? 
### Should I be doing t tests on log-transformed data if that is more normal? 
svyhist(~urxuhg,
        uhg.svy,
        main = "Survey weighted average urine Hg", col = "blue")

# log transformed
svyhist(~log(urxuhg),
        uhg.svy,
        main = "Survey weighted log(average urine Hg)", col = "blue")
## Still not very normal... 

tt_uhg <-
  svyttest(urxuhg~sex,
           uhg.svy)

tt_uhg

# the difference here is significant but it was done on a non-normal distribution 

```

```{r download arsenic data and clean, eval=FALSE, include=FALSE}

# Merge data to create one dataframe per year/NHANES cycle
arsenic_1516 <- merge(uas_sp, uas_t, by = c("SEQN", "WTSA2YR"), all = TRUE)
arsenic_1516 <- merge(arsenic_1516, demo1516, by = "SEQN", all = TRUE)

# Retain only necessary variables:
# uhg_1516 <-
#   uhg_1516 %>%
#   select(SEQN, SDDSRVYR, # unique identifier and survey year 
#          RIAGENDR, RIDAGEYR, RIDRETH1, # gender, age, race/ethnicity
#          WTMEC2YR, SDMVPSU, SDMVSTRA, WTSA2YR, # weighting info, NOTICE IT'S DIFFERENT NOW 
#          URXUHG) # urine mercury
 
head(arsenic_1516)

# clean / rename variable names
arsenic_1516 <-
  arsenic_1516 %>%
  janitor::clean_names() %>% 
  rename(sex = riagendr,
         age = ridageyr,
         race = ridreth1) %>% 
  set_value_labels(
    sex = c("Male" = 1, "Female" = 2), 
    race = c("Mexican American" = 1, "Other Hispanic" = 2, "NH White" = 3, "NH Black" = 4, "Other including multi" = 5)) %>% 
  mutate_if(is.labelled, to_factor) %>% 
  drop_na(wtsa2yr, urxuas)

glimpse(arsenic_1516)

```

```{r arsenic descriptive stats, eval=FALSE, include=FALSE}

## svyby: Survey stats on subsets of data (or, survey stats across levels of factors)
svyby(~urxuas, # continuous variable
      by = ~sex, # groups
      arsenic.svy, # the ”svydesign” object 
      svymean)  # the function you want 

```

```{r urinary arsenic graphs, eval=FALSE, include=FALSE}

# first, some data manipulation
# combine species into inorganic species and organic species


```

### Urinary Total As and DMA

**Need to adjust for arsenobetaine. Or just plot arsenobetaine and DMA? See Annie's methods.**

```{r adjust total As and DMA for arsenobetaine and creatinine}

# AsB is found in seafood and considered to be relatively nontoxic (Choi et al., 2010, Heinrich-Ramm et al., 2002). Therefore, we uses a residual method to provide an estimate of arsenic exposure that minimizes the potential influence of seafood arsenic intake (Jones et al., 2016). This approach yields a calibrated urinary biomarker by regressing DMA by AsB and extracting the model residuals [e.g. ln(DMAi)= β0 + β1 ×ln(arsenobetainei)+ εi]. Additionally, we conducted a sensitivity analysis that used a residual adjusted total urinary arsenic [e.g. ln(Total As)= β0 + β1 ×ln(arsenobetainei)+ εi]. Finally, we used data from 24-h dietary recall to create a variable of recent seafood consumption (yes/no) (Welch et al., 2018). Urinary creatinine was measured by an enzymatic method by a Roche/Hitachi Modular P Chemistry Analyzer. Urinary creatinine was used as a separate independent variable to adjust for differences in urine dilution (Barr et al., 2005).

# Urinary concentrations of iAs, MMA and DMA from exposure to iAs were obtained by regressing the measured concentrations of iAs, MMA, and DMA on arsenobetaine concentrations using a log-log regression model as follows: log(arsenicali)=β0+β1×log(arsenobetainei)+εi,for i in 1,…,N, where arsenical corresponds to iAs, MMA, or DMA, β0 and β1 correspond to the intercept and slope coefficients, and εi represents the residuals in the ith individual of N total individuals.

# for Total Arsenic, adjusted for arsenobetaine and creatinine
arsenic_model <- svyglm(log(urxuas)~urxucr+log(urxuab), 
                 arsenic.svy)
# should I also include independent variables for age, sex, and race/ethnicity? What about BMI?

summary(arsenic_model)

# for DMA, adjusted for arsenobetaine and creatinine
dma_model <- svyglm(log(urxudma)~urxucr+log(urxuab), 
                 arsenic.svy)
# should I also include independent variables for age, sex, and race/ethnicity? What about BMI?

summary(dma_model)

# extract the residuals 
as_adj <- residuals(arsenic_model)
dma_adj <- residuals(dma_model)
# now, add the mean levels of the corresponding arsenic species (iAs or DMA estimated from participants with low arsenobetaine (<1 µg/L)) to the residuals

# calculate mean iAs and DMA among participants with low arsenobetaine
low_urxuab <-
  uas1516_sub %>% 
  filter(urxuab < 1.0)

mean(low_urxuab$urxuas) # add the mean or geometric mean? 
# 4.663655
mean(low_urxuab$urxudma)
# 3.217484

# add these means to the residuals
uas_total <- as_adj + 4.663655
uas_dma <- dma_adj + 3.217484

# the calibrated biomarkers for total arsenic and DMA should no longer reflect organic arsenicals from seafood

```


#### Total As

```{r urinary total As, eval=FALSE, include=FALSE}

### OVERALL 

# Count number of males and females in this dataset
table(uas1516_sub$sex)
100*(svymean(~sex, arsenic.svy)) # weighted percentage of individuals by sex
#            mean     SE
# sexMale   48.851 0.0143
# sexFemale 51.149 0.0143


# overall population geometric mean and 95% CI
total_as_log_mean <-
  svymean(~log(urxuas), 
          arsenic.svy) 

## Geometric mean, meHg
exp(total_as_log_mean)[1]

## 95% Confidence Intervals
# Geometric mean lower 95% confidence interval
exp(total_as_log_mean[1] - 1.96 * sqrt(attr(total_as_log_mean, "var")))
# Geometric mean upper 95% confidence interval
exp(total_as_log_mean[1] + 1.96 * sqrt(attr(total_as_log_mean, "var")))

### BY SEX

# meHg by sex
svyby(~log(urxuas),
      by = ~sex,
      arsenic.svy,
      svymean)

# Males
# Geometric mean and 95% CI
exp(-11.98918) # 6.211054e-06 ug/L, geometric mean for males
exp(-11.98918 - (1.96 * 0.03606566)) # lower 95% CI
exp(-11.98918 + (1.96 * 0.03606566)) # upper 95% CI

# Females
# Geometric mean and 95% CI
exp(-11.84353) # 7.184893e-06 ug/L, geometric mean for females
exp(-11.84353 - (1.96 * 0.04397272)) # lower 95% CI
exp(-11.84353 + (1.96 * 0.04397272)) # upper 95% CI
# note that the exponentiated form of the mean of a log-transformed variable is the GEOMETRIC MEAN! 

# To determine if this difference is statistically significnat, I do a t-test because I am comparing the mean of a continuous variable across two groups 
tt_urxuas <-
  svyttest(log(urxuas)~sex,
           arsenic.svy)

tt_urxuas


```

#### DMA 

```{r DMA}

```


```{r examples, eval=FALSE, include=FALSE}

# Useful svy functions: 
#  svydesign: Defines the survey design for your dataset. This is the foundation of the package! 
#  svymean: Computes means and SEs for survey data
#  svyhist: Survey-weighted histograms (ugly, but functional...)
#  svyquantile: Computes quantiles for survey data (you can choose the quantile values)
#  svychisq: Contingency table and chi-squared tests for survey data; weighted cross tabulations
#  svyby: Survey stats on subsets of data (or, survey stats across levels of factors)
#  svyglm: General linear models for survey data (simliar to 'glm')
#  svyttest: T-tests

## svyhist: Survey-weighted histograms
 
## svyquantile: Computes quantiles for survey data (you can choose the quantile values)
# EXAMPLE: 
svyquantile(~lbxbpb, # continuous variable  
            nhanes.svy, # the ”svydesign” object
            c(0.10, 0.90), # list of percentiles
            ci = F)

## S3 method for class 'survey.design'
svyquantile(x,
            design,
            quantiles,
            alpha=0.05,
            ci=FALSE,
            method = "linear",
            f = 1,
            interval.type=c("Wald","score","betaWald"),
            na.rm=FALSE,
            se=ci,
            ties=c("discrete","rounded"), df=Inf,...)

############################

## svychisq: Contingency table and chi-squared tests for survey data; weighted cross tabulations
# EXAMPLE CODE for chi-squared test
# Note: Hypertension variable does not exist in our nh1516_sub dataframe

# We are comparing a binary variable (hypertension status) across a categorical variable, so let's use a chi-squared test. We can get the raw numbers from a simple table.
nhanes.svy <-
  svydesign(ids = ~sdmvpsu, 
            strata = ~sdmvstra,  
            weights = ~wtsh2yr, 
            nest = TRUE,
            data = nh1516_sub) #Re-setting the svydesign!

# Contingency table and chi-squared tests for survey data using svychisq
table(nh1516_sub$htn,
      nh1516_sub$race)

svychisq(~htn+sex,
         nhanes.svy,
         statistic="adjWald") 

############################

```



